// Workday Query Language (WQL) Tokenizer

var TOKEN_TYPES = {
    "PARAMETERS": 'PARAMETERS', "SELECT": 'SELECT', "FROM": 'FROM', "WHERE": 'WHERE', "ON": 'ON',
    "GROUP_BY": 'GROUP BY', "ORDER_BY": 'ORDER BY', "HAVING": 'HAVING', "LIMIT": 'LIMIT',
    "AND": 'AND', "OR": 'OR', "NOT": 'NOT', "IN": 'IN', "IS": 'IS', "NULL": 'NULL',
    "EMPTY": 'EMPTY', "AS": 'AS', "ASC": 'ASC', "DESC": 'DESC', "DISTINCT": 'DISTINCT',
    "STARTSWITH": 'STARTSWITH', "ENDSWITH": 'ENDSWITH', "CONTAINS": 'CONTAINS',
    "NOT_CONTAINS": 'NOT CONTAINS', "NOT_IN": 'NOT IN', "IS_EMPTY": 'IS EMPTY', "IS_NOT_EMPTY": 'IS NOT EMPTY',
    
    "AGGREGATION_FUNCTION": 'AGGREGATION_FUNCTION', "DATASOURCE": 'DATASOURCE',
    "DATASOURCE_FILTER_KEYWORD": 'DATASOURCE_FILTER_KEYWORD', "DATASOURCE_FILTER": 'DATASOURCE_FILTER',
    "PARAMETER_NAME": 'PARAMETER_NAME', "FIELD": 'FIELD', "RBO_NAME": 'RBO_NAME', "RBO_FIELD": 'RBO_FIELD',
    "DATASOURCE_PARAMETER_KEYWORD": 'DATASOURCE_PARAMETER_KEYWORD', "ALIAS": 'ALIAS',
    "STRING": 'STRING', "NUMBER": 'NUMBER', "BOOLEAN": 'BOOLEAN', "OPERATOR": 'OPERATOR',
    "COMMA": 'COMMA', "LPAREN": 'LPAREN', "RPAREN": 'RPAREN', "LBRACE": 'LBRACE',
    "RBRACE": 'RBRACE', "EQUALS": 'EQUALS', "IN_LIST": 'IN_LIST',
    "PARAMETER_LIST": 'PARAMETER_LIST', "REFERENCE_ID": 'REFERENCE_ID',
    "WORKDAY_ID": 'WORKDAY_ID', "DATE": 'DATE', "DATETIME": 'DATETIME', "EOF": 'EOF'
};

var KEYWORDS = {
    'PARAMETERS': true, 'SELECT': true, 'FROM': true, 'WHERE': true, 'ON': true, 'GROUP': true, 'BY': true, 'ORDER': true,
    'HAVING': true, 'LIMIT': true, 'AND': true, 'OR': true, 'NOT': true, 'IN': true, 'IS': true, 'NULL': true, 'EMPTY': true, 'AS': true,
    'ASC': true, 'DESC': true, 'STARTSWITH': true, 'ENDSWITH': true, 'CONTAINS': true, 'DISTINCT': true
};

var AGGREGATION_FUNCTIONS = { 'AVG': true, 'COUNT': true, 'MIN': true, 'MAX': true, 'SUM': true };
var BOOLEANS = { 'TRUE': true, 'FALSE': true };

var createToken = function(type, value, position) {
    return { "type": type, "value": value, "position": position };
};

var isWhitespace = function(char) { return char == ' ' || char == '\t' || char == '\n' || char == '\r'; };
var isDigit = function(char) { return char >= '0' && char <= '9'; };
var isAlphaNumeric = function(char) { return (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9') || char == '_'; };
var isKeyword = function(str) { if (empty(str)) { return false; } return KEYWORDS[str.upperCase()] == true; };
var isAggregationFunction = function(str) { if (empty(str)) { return false; } return AGGREGATION_FUNCTIONS[str.upperCase()] == true; };
var isBoolean = function(str) { if (empty(str)) { return false; } return BOOLEANS[str.upperCase()] == true; };
var isWorkdayId = function(str) { if (empty(str)) { return false; } if (str.size() != 32) return false; for (var i = 0; i < str.size(); i++) { var char = str.substring(i, i + 1); if (!((char >= '0' && char <= '9') || (char >= 'a' && char <= 'f') || (char >= 'A' && char <= 'F'))) { return false; } } return true; };
var isDateLiteral = function(str) { if (empty(str)) { return false; } if (str.size() != 10) return false; return str.substring(4, 5) == '-' && str.substring(7, 8) == '-' && isDigit(str.substring(0, 1)) && isDigit(str.substring(1, 2)) && isDigit(str.substring(2, 3)) && isDigit(str.substring(3, 4)) && isDigit(str.substring(5, 6)) && isDigit(str.substring(6, 7)) && isDigit(str.substring(8, 9)) && isDigit(str.substring(9, 10)); };
var isDateTimeLiteral = function(str) { if (empty(str)) { return false; } if (str.size() < 19) return false; var datePart = str.substring(0, 10); if (!isDateLiteral(datePart)) return false; if (str.substring(10, 11) != ' ') return false; var timePart = str.substring(11, 19); return timePart.substring(2, 3) == ':' && timePart.substring(5, 6) == ':' && isDigit(timePart.substring(0, 1)) && isDigit(timePart.substring(1, 2)) && isDigit(timePart.substring(3, 4)) && isDigit(timePart.substring(4, 5)) && isDigit(timePart.substring(6, 7)) && isDigit(timePart.substring(7, 8)); };
var peekNextWord = function(input, position) { var inputLength = input.size(); while (position < inputLength && isWhitespace(input.substring(position, position + 1))) { position++; } var word = ''; while (position < inputLength && isAlphaNumeric(input.substring(position, position + 1))) { word += input.substring(position, position + 1); position++; } return word; };
var parseList = function(input, startPosition, requireParentheses) { var values = []; var position = startPosition; var inputLength = input.size(); var inParentheses = false; while (position < inputLength && isWhitespace(input.substring(position, position + 1))) { position++; } if (position < inputLength && input.substring(position, position + 1) == '(') { inParentheses = true; position++; } else if (requireParentheses) { return { "values": [], "endPosition": startPosition }; } while (position < inputLength) { while (position < inputLength && isWhitespace(input.substring(position, position + 1))) { position++; } if (position >= inputLength) break; var char = input.substring(position, position + 1); if (inParentheses && char == ')') { position++; break; } else if (!inParentheses && (char == ')' || isKeyword(peekNextWord(input, position)))) { break; } var value = ''; if (char == "'" || char == '"') { var quote = char; position++; while (position < inputLength && input.substring(position, position + 1) != quote) { value += input.substring(position, position + 1); position++; } if (position < inputLength) { position++; } values.add(value); } else { while (position < inputLength) { char = input.substring(position, position + 1); if (char == ',' || (inParentheses && char == ')') || (!inParentheses && isWhitespace(char) && isKeyword(peekNextWord(input, position)))) { break; } if (!isWhitespace(char)) { value += char; } position++; } if (value.size() > 0) { values.add(value); } } while (position < inputLength && isWhitespace(input.substring(position, position + 1))) { position++; } if (position < inputLength && input.substring(position, position + 1) == ',') { position++; continue; } else { break; } } return { "values": values, "endPosition": position }; };
var isComplexInClause = function(input, startPosition) { if (empty(input)) { return false; } var pos = startPosition; var inputLength = input.size(); while(pos < inputLength && isWhitespace(input.substring(pos, pos + 1))) { pos++; } if (pos >= inputLength || input.substring(pos, pos + 1) != '(') { return false; } pos++; while(pos < inputLength && isWhitespace(input.substring(pos, pos + 1))) { pos++; } var identifier = ''; while(pos < inputLength && isAlphaNumeric(input.substring(pos, pos + 1))) { identifier += input.substring(pos, pos + 1); pos++; } if (identifier.size() == 0) { return false; } while(pos < inputLength && isWhitespace(input.substring(pos, pos + 1))) { pos++; } if (pos < inputLength && input.substring(pos, pos + 1) == '=') { return true; } return false; };

var tokenize = function(input) {
    if (empty(input)) {
        var emptyTokens = [];
        emptyTokens.add(createToken(TOKEN_TYPES.EOF, null, 0));
        return emptyTokens;
    }

    var tokens = []; var position = 0; var inputLength = input.size();
    var inParametersClause = false; var inFromClause = false; var inDataSourceParens = false; var expectingAlias = false; var expectingDataSourceFilterValue = false; var expectingParameterValue = false; var expectingInList = false; var expectingParameterList = false; var expectingRboField = false; var whereOnState = 0;

    while (position < inputLength) {
        var startPos = position;
        var char = input.substring(position, position + 1);

        if (isWhitespace(char)) { position++; continue; }
        if (expectingInList) { var listResult = parseList(input, position, false); tokens.add(createToken(TOKEN_TYPES.IN_LIST, listResult.values, startPos)); position = listResult.endPosition; expectingInList = false; continue; }
        if (expectingParameterList) { var listResult = parseList(input, position, true); if (listResult.values.size() > 0) { tokens.add(createToken(TOKEN_TYPES.PARAMETER_LIST, listResult.values, startPos)); position = listResult.endPosition; } expectingParameterList = false; continue; }

        if (char == "'" || char == '"') {
            var quote = char; var value = ''; position++;
            while (position < inputLength && input.substring(position, position + 1) != quote) { value += input.substring(position, position + 1); position++; }
            if (position < inputLength) { position++; }
            var tokenType = TOKEN_TYPES.STRING;
            if (isWorkdayId(value)) { tokenType = TOKEN_TYPES.WORKDAY_ID; } else if (isDateLiteral(value)) { tokenType = TOKEN_TYPES.DATE; } else if (isDateTimeLiteral(value)) { tokenType = TOKEN_TYPES.DATETIME; }
            tokens.add(createToken(tokenType, value, startPos));
            if (expectingAlias) { var lastToken = tokens.get(tokens.size() - 1); lastToken.type = TOKEN_TYPES.ALIAS; }
            expectingAlias = false; expectingDataSourceFilterValue = false; expectingParameterValue = false;
            continue;
        }

        if (isDigit(char) || (char == '.' && position + 1 < inputLength && isDigit(input.substring(position + 1, position + 2)))) {
            var numValue = ''; var hasDecimal = false;
            while (position < inputLength) { var currentChar = input.substring(position, position + 1); if (isDigit(currentChar)) { numValue += currentChar; } else if (currentChar == '.' && !hasDecimal) { numValue += currentChar; hasDecimal = true; } else { break; } position++; }
            tokens.add(createToken(TOKEN_TYPES.NUMBER, numValue, startPos));
            expectingAlias = false; expectingParameterValue = false;
            continue;
        }

        if (char == '(') { tokens.add(createToken(TOKEN_TYPES.LPAREN, '(', startPos)); var lastToken = tokens.size() > 1 ? tokens.get(tokens.size() - 2) : null; if (!empty(lastToken)) { if (lastToken.type == TOKEN_TYPES.DATASOURCE) { inDataSourceParens = true; } } position++; continue; }
        if (char == '{') { tokens.add(createToken(TOKEN_TYPES.LBRACE, '{', startPos)); var lastToken = tokens.size() > 1 ? tokens.get(tokens.size() - 2) : null; if (!empty(lastToken)) { if (lastToken.type == TOKEN_TYPES.FIELD) { lastToken.type = TOKEN_TYPES.RBO_NAME; expectingRboField = true; } } position++; continue; }
        if (char == '}') { tokens.add(createToken(TOKEN_TYPES.RBRACE, '}', startPos)); expectingRboField = false; position++; continue; }
        if (char == ')') { tokens.add(createToken(TOKEN_TYPES.RPAREN, ')', startPos)); inDataSourceParens = false; expectingDataSourceFilterValue = false; expectingParameterValue = false; position++; continue; }
        if (char == ',') { tokens.add(createToken(TOKEN_TYPES.COMMA, ',', startPos)); expectingDataSourceFilterValue = false; expectingParameterValue = false; if (whereOnState == 2) { whereOnState = 1; } position++; continue; }
        if (char == '=') { tokens.add(createToken(TOKEN_TYPES.EQUALS, '=', startPos)); var prevToken = tokens.size() > 1 ? tokens.get(tokens.size() - 2) : null; if (!empty(prevToken)) { if (prevToken.type == TOKEN_TYPES.DATASOURCE_FILTER_KEYWORD) { expectingDataSourceFilterValue = true; } else if (prevToken.type == TOKEN_TYPES.PARAMETER_NAME) { expectingParameterValue = true; } else if (inDataSourceParens && (prevToken.type == TOKEN_TYPES.FIELD || prevToken.type == TOKEN_TYPES.PARAMETER_NAME)) { var peekPos = position + 1; while (peekPos < inputLength && isWhitespace(input.substring(peekPos, peekPos + 1))) { peekPos++; } if (peekPos < inputLength && input.substring(peekPos, peekPos + 1) == '(') { expectingParameterList = true; } } } position++; continue; }
        if (char == '<' || char == '>' || char == '!') { var nextChar = position + 1 < inputLength ? input.substring(position + 1, position + 2) : null; if (char == '<' && nextChar == '>') { tokens.add(createToken(TOKEN_TYPES.OPERATOR, '<>', startPos)); position += 2; } else if (char == '<' && nextChar == '=') { tokens.add(createToken(TOKEN_TYPES.OPERATOR, '<=', startPos)); position += 2; } else if (char == '>' && nextChar == '=') { tokens.add(createToken(TOKEN_TYPES.OPERATOR, '>=', startPos)); position += 2; } else if (char == '!' && nextChar == '=') { tokens.add(createToken(TOKEN_TYPES.OPERATOR, '!=', startPos)); position += 2; } else { tokens.add(createToken(TOKEN_TYPES.OPERATOR, char, startPos)); position++; } continue; }

        if (isAlphaNumeric(char)) {
            var item = ''; var tempPos = position;
            while (tempPos < inputLength && isAlphaNumeric(input.substring(tempPos, tempPos + 1))) { item += input.substring(tempPos, tempPos + 1); tempPos++; }
            var upperItem = item.upperCase(); var tokenType;
            
            var nextWord = ''; var thirdWord = ''; var posAfterNext = tempPos; var posAfterThird = -1; var peekPos = tempPos; while (peekPos < inputLength && isWhitespace(input.substring(peekPos, peekPos + 1))) peekPos++; if (peekPos < inputLength && isAlphaNumeric(input.substring(peekPos, peekPos + 1))) { posAfterNext = peekPos; while (posAfterNext < inputLength && isAlphaNumeric(input.substring(posAfterNext, posAfterNext + 1))) { nextWord += input.substring(posAfterNext, posAfterNext + 1); posAfterNext++; } peekPos = posAfterNext; while (peekPos < inputLength && isWhitespace(input.substring(peekPos, peekPos + 1))) peekPos++; if (peekPos < inputLength && isAlphaNumeric(input.substring(peekPos, peekPos + 1))) { posAfterThird = peekPos; while (posAfterThird < inputLength && isAlphaNumeric(input.substring(posAfterThird, posAfterThird + 1))) { thirdWord += input.substring(posAfterThird, posAfterThird + 1); posAfterThird++; } } }
            if (upperItem == 'IS' && nextWord.upperCase() == 'NOT' && thirdWord.upperCase() == 'EMPTY') { tokens.add(createToken(TOKEN_TYPES.IS_NOT_EMPTY, 'is not empty', startPos)); position = posAfterThird; continue; } if (upperItem == 'NOT' && nextWord.upperCase() == 'CONTAINS') { tokens.add(createToken(TOKEN_TYPES.NOT_CONTAINS, 'not contains', startPos)); position = posAfterNext; continue; } if (upperItem == 'NOT' && nextWord.upperCase() == 'IN') { tokens.add(createToken(TOKEN_TYPES.NOT_IN, 'not in', startPos)); position = posAfterNext; if (isComplexInClause(input, posAfterNext)) { expectingInList = false; } else { expectingInList = true; } continue; } if (upperItem == 'IS' && nextWord.upperCase() == 'EMPTY') { tokens.add(createToken(TOKEN_TYPES.IS_EMPTY, 'is empty', startPos)); position = posAfterNext; continue; } if (upperItem == 'GROUP' && nextWord.upperCase() == 'BY') { tokens.add(createToken(TOKEN_TYPES.GROUP_BY, 'group by', startPos)); position = posAfterNext; continue; } if (upperItem == 'ORDER' && nextWord.upperCase() == 'BY') { tokens.add(createToken(TOKEN_TYPES.ORDER_BY, 'order by', startPos)); position = posAfterNext; continue; }

            position = tempPos;
            
            if (upperItem == 'ON') { var lastToken = tokens.size() > 0 ? tokens.get(tokens.size() - 1) : null; if (!empty(lastToken)) { if (lastToken.type == TOKEN_TYPES.WHERE) { whereOnState = 1; } } }
            else if (isKeyword(item) && upperItem != 'AND' && upperItem != 'OR' && whereOnState > 0) { whereOnState = 0; }

            if (expectingDataSourceFilterValue) { tokenType = TOKEN_TYPES.DATASOURCE_FILTER; expectingDataSourceFilterValue = false; }
            else if (isKeyword(item)) {
                tokenType = upperItem;
                if (tokenType == TOKEN_TYPES.PARAMETERS) { inParametersClause = true; inFromClause = false; inDataSourceParens = false; }
                else if (tokenType == TOKEN_TYPES.FROM) { inFromClause = true; inParametersClause = false; inDataSourceParens = false; }
                else if (tokenType == TOKEN_TYPES.AS) { expectingAlias = true; }
                else if (tokenType == TOKEN_TYPES.IN) { if (isComplexInClause(input, tempPos)) { expectingInList = false; } else { expectingInList = true; } }
                else if (tokenType == TOKEN_TYPES.SELECT || tokenType == TOKEN_TYPES.WHERE) { inParametersClause = false; inFromClause = false; inDataSourceParens = false; }
            }
            else if (expectingParameterValue) { tokenType = isWorkdayId(item) ? TOKEN_TYPES.WORKDAY_ID : TOKEN_TYPES.FIELD; expectingParameterValue = false; }
            else if (expectingRboField) { tokenType = TOKEN_TYPES.RBO_FIELD; }
            else if (whereOnState == 1) { tokenType = TOKEN_TYPES.RBO_NAME; whereOnState = 2; }
            else if (whereOnState == 2) { tokenType = TOKEN_TYPES.RBO_FIELD; }
            else if (expectingAlias) { tokenType = TOKEN_TYPES.ALIAS; expectingAlias = false; }
            else if (inParametersClause) { tokenType = TOKEN_TYPES.PARAMETER_NAME; }
            else if (inFromClause) { tokenType = TOKEN_TYPES.DATASOURCE; inFromClause = false; }
            else if (inDataSourceParens) {
                if (upperItem == 'DATASOURCEFILTER') {
                    tokenType = TOKEN_TYPES.DATASOURCE_FILTER_KEYWORD;
                    expectingDataSourceFilterValue = true;
                } else {
                    // Treat any other identifier in the FROM parens as a field/prompt.
                    tokenType = TOKEN_TYPES.FIELD;
                }
            }
            else if (isAggregationFunction(item)) { tokenType = TOKEN_TYPES.AGGREGATION_FUNCTION; }
            else if (isBoolean(item)) { tokenType = TOKEN_TYPES.BOOLEAN; }
            else if (isWorkdayId(item)) { tokenType = TOKEN_TYPES.WORKDAY_ID; }
            else { tokenType = TOKEN_TYPES.FIELD; }
            
            tokens.add(createToken(tokenType, item, startPos));
            continue;
        }
        position++;
    }
    tokens.add(createToken(TOKEN_TYPES.EOF, null, position));
    return tokens;
};

var enrichTokensWithSource = function(tokens) {
    var dataSource = null;
    var currentRbo = null;

    for (var i = 0; i < tokens.size(); i++) {
        if (tokens.get(i).type == TOKEN_TYPES.DATASOURCE) {
            dataSource = tokens.get(i).value;
            break;
        }
    }

    if (empty(dataSource)) {
        return tokens;
    }

    for (var i = 0; i < tokens.size(); i++) {
        var token = tokens.get(i);

        if (token.type == 'RBO_NAME') {
            token.source = dataSource;
            currentRbo = token.value;
        } else if (token.type == 'RBO_FIELD') {
            token.source = currentRbo;
        } else if (token.type == 'FIELD') {
            token.source = dataSource;
        } else if (token.type == TOKEN_TYPES.RBRACE) {
            currentRbo = null;
        }
    }
    return tokens;
};

var tokenizeWQL = function(wql) {
    var basicTokens = tokenize(wql);
    var enrichedTokens = enrichTokensWithSource(basicTokens);
    return enrichedTokens;
};

{
    "tokenizeWQL": tokenizeWQL
}